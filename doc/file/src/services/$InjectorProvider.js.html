<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/services/$InjectorProvider.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/benderTheCrime/angie-injector.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div data-ice="classWrap">
  <h2>Class</h2>
  <ul>
    
  <li data-ice="classDoc"><span><a href="class/src/services/$InjectorProvider.js~$InjectorProvider.html">$InjectorProvider</a></span></li>
</ul>
</div>










</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/services/$InjectorProvider.js</h1>
<pre class="source-code line-number"><code class="prettyprint linenums" data-ice="content">/**
 * @module $InjectorProvider.js
 * @author Joe Groseclose &lt;@benderTheCrime&gt;
 * @date 8/23/2015
 */

// System Modules
import {bold, red} from   &apos;chalk&apos;;

const bread = (v) =&gt; bold(red(v));
let $$injectorRoot;

/**
 * @desc Handles dependency injection, will return one or many arguments passed
 * as a string or an array.
 * @since 0.0.1
 * @access public
 * @example $Injector.get(&apos;test&apos;);
 */
class $InjectorProvider {

    /**
     * @desc Responsible for routing of dependencies
     * @since 0.0.1
     * @access public
     * @param {object|string} The name or array of names of providers to fetch
     * @returns {object|string|number|Array&lt;&gt;|boolean} The provider value
     * @example $Injector.get(&apos;$scope&apos;); // = { $id: 1 }
     */
    static get() {

        // Declare the root from which dependencies are provided and check keys
        $$injectorRoot = $$injectorRoot || global.app || {};
        if (!Object.keys($$injectorRoot).length) {
            throw new $$ProviderDomainError();
        }

        let registrar,
            providers = [],
            args = arguments[0] instanceof Array ?
                arguments[0] : Array.from(arguments),
            type = arguments[0] instanceof Array &amp;&amp; arguments[1] ?
                arguments[1] : null;

        // Check to see if a registrar exists
        if (typeof $$injectorRoot.$$registry === &apos;object&apos;) {
            registrar = $$injectorRoot.$$registry;
        }

        // Check to see if there are any preceeding empty args
        if (args.length &amp;&amp; args[0] === &apos;&apos;) {
            args.shift();
        }

        args.forEach(function(arg) {
            let provider;

            // Doing this for safety reasons...if the arg didn&apos;t come from IB,
            // it potentially has unsafe spaces, underscores
            arg = arg.toString().replace(/[_\s]/g, &apos;&apos;);

            // Rename convention for the $scope service
            if (arg === &apos;scope&apos;) {
                arg = &apos;$scope&apos;;
            } else if (
                registrar &amp;&amp; registrar[ arg ] === &apos;Model&apos; &amp;&amp;
                type &amp;&amp; type === &apos;directive&apos;
            ) {
                throw new $$ProviderTypeError();
            }

            // Try to find the provider in the registrar or the declared object
            // else return;
            try {
                provider = registrar ?
                    $$injectorRoot[ registrar[ arg ] ][ arg ] :
                    $$injectorRoot[ arg ];
                if (provider) {
                    providers.push(provider);
                    return;
                }
                throw new Error();
            }
            catch(e) {

                // If no provider could be found, there is a big problem
                throw new $$ProviderNotFoundError(arg);
            }
        });
        return providers.length &gt; 1 ? providers : providers[0] ? providers[0] : [];
    }

    /**
     * @desc Specifies the root object from which dependencies are fetched
     * @since 0.0.1
     * @access public
     * @param {object} r [param={}] The object from which dependencies are
     * fetched
     * @returns {object} The root object vaule
     * @example $Injector.$specifyInjectorRoot({});
     */
    static $specifyInjectorRoot(r = {}) {
        $$injectorRoot = r;
        return r;
    }
}

/**
 * @desc Responsible for binding of dependencies to functions
 * @since 0.0.1
 * @access public
 * @param {function} The function to which values are being provided
 * @returns {function} Bound function
 */
function $injectionBinder(fn = () =&gt; undefined, type) {
    let str = fn.toString(),
        args = str.match(/(function.*)?\(.*\)(\s+\=\&gt;)?/g),
        providers = [];

    args = args.map((v) =&gt; v.replace(/[_\s]/g, &apos;&apos;));
    if (args &amp;&amp; args.length) {

        // TODO this is probably one of the worst RegExps ever written. It is
        // intended to match:
        // Anonymous functions
        // Named functions
        // Arrow functions
        // Closing brackets
        args = args[0].replace(
            /(\(|function(\s+)?([^\)\(]+)?(\s+)?\(|\)(\s+)?(=&gt;)?(\s+)?)/g,
            &apos;&apos;
        ).split(&apos;,&apos;).map((v) =&gt; v.trim());
        providers = $InjectorProvider.get.apply(global.app, args, type);
    }
    return typeof providers === &apos;object&apos; ?
        fn.bind(null, ...providers) : providers ?
            fn.bind(null, providers) : fn.bind(null);
}

/**
 * @desc Handles Errors for unfound injection resources based on RangeError
 * @since 0.0.1
 * @extends {RangeError}
 * @access private
 */
class $$ProviderNotFoundError extends RangeError {
    constructor(name) {
        console.log(bread(`Cannot find ${name} &lt;-- ${name}Provider`));
        super();
    }
}

/**
 * @desc Handles Errors for empty $Injector requests based on ReferenceError
 * @since 0.0.1
 * @extends {ReferenceError}
 * @access private
 */
class $$ProviderDomainError extends ReferenceError {
    constructor() {
        console.log(bread(&apos;No dependencies to inject&apos;));
        super();
    }
}

/**
 * @desc Handles Errors for empty $Injector requests based on ReferenceError
 * @since 0.0.1
 * @extends {ReferenceError}
 * @access private
 */
class $$ProviderTypeError extends TypeError {
    constructor() {
        console.log(bread(
            &apos;Models cannot be called as arguments to directives. You may &apos; +
            &apos;manually inject these using `$inject.get` if you so choose&apos;
        ));
        super();
    }
}

export default $InjectorProvider;
export {
    $injectionBinder,
    $$ProviderDomainError,
    $$ProviderNotFoundError,
    $$ProviderTypeError
};</code></pre>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.1.2)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
